---
title: "Raster geoms"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{"Raster geoms"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## ggrastr

### Points: Rasterize scatterplots with geom_point_rast()
Sometimes you need to publish a figure in a vector format:
```{r, fig.width=4, fig.height=4}
library(ggplot2)
library(ggrastr)

points_num <- 50  
df <- data.frame(x=rnorm(points_num), y=rnorm(points_num), c=as.factor(1:points_num %% 2))
gg <- ggplot(df, aes(x=x, y=y, color=c)) + scale_color_discrete(guide=F)

gg_vec <- gg + geom_point(size=0.5)
print(gg_vec)
```

But in other cases, your figure contains thousands of points, e.g. try `points_num <- 500000` in the example above, and you will notice the performance issues---it takes significantly longer to render the plot:

![gg_vec_plot_500000](ggvec_50000_plot.png)


In this case, a reasonable solution would be to rasterize the plot. But the problem is that all text becomes rasterized as well.
Raster layers with `ggrastr` were developed to prevent such a situation, here using `geom_point_rast()`:
```{r, fig.width=4, fig.height=4}
gg_rast <- gg + geom_point_rast(size=0.5)
print(gg_rast)
```

The plots look the same, but the difference in size can be seen when they are exported to pdfs. Unfortunately, there is a longer rendering time to produce such plots:
```{r}
PrintFileSize <- function(gg, name) {
  invisible(ggsave('tmp.pdf', gg, width = 4, height = 4))
  cat(name, ': ', file.info('tmp.pdf')$size / 1024, ' Kb.\n', sep = '')
  unlink('tmp.pdf')
}

PrintFileSize(gg_rast, 'Raster')
PrintFileSize(gg_vec, 'Vector')
```

As expected, the difference becomes larger with growth of number of points:
```{r}
points_num <- 1000000
df <- data.frame(x=rnorm(points_num), y=rnorm(points_num), c=as.factor(1:points_num %% 2))
gg <- ggplot(df, aes(x=x, y=y, color=c)) + scale_color_discrete(guide=F)

gg_vec <- gg + geom_point(size=0.5)
gg_rast <- gg + geom_point_rast(size=0.5)

PrintFileSize(gg_rast, 'Raster')
PrintFileSize(gg_vec, 'Vector')
```

### Jitter: Rasterize jittered scatterplots with geom_jitter_rast()

Just like the example above with`geom_point_rast()`, users may also opt to create rasterized scatterplots with jitter. The geom `geom_jitter_rast()` is similar to `ggplot2::geom_jitter()`, but it creates a rasterized layer:


```{r, fig.width=4, fig.height=4}
library(ggplot2)
library(ggrastr)

points_num <- 5000 
df <- data.frame(x=rnorm(points_num), y=rnorm(points_num), c=as.factor(1:points_num %% 2))
gg <- ggplot(df, aes(x=x, y=y, color=c)) + scale_color_discrete(guide=F)

gg_jitter_rast <- gg + geom_jitter_rast(raster.dpi = 600)
print(gg_jitter_rast)
```



### Tiles: Rasterize heatmaps with geom_tile_rast()

Heatmaps also have similar issues with the default verctorized formats:


```{r}
library(ggplot2)
library(ggrastr)

coords <- expand.grid(1:500, 1:500)
coords$Value <- 1 / apply(as.matrix(coords), 1, function(x) sum((x - c(50, 50))^2)^0.01)
gg_tile_vec <- ggplot(coords) + geom_tile(aes(x=Var1, y=Var2, fill=Value))
gg_tile_rast <- ggplot(coords) + geom_tile_rast(aes(x=Var1, y=Var2, fill=Value))
```

We can see that the rasterized plots using `ggrastr` are lighter in size when rendered to pdf:

```{r}
PrintFileSize(gg_tile_rast, 'Raster')
PrintFileSize(gg_tile_vec, 'Vector')
```



### Boxplots: jitter outliers and rasterize boxplots with geom_boxplot_jitter

Another type of plots with a potentially large number of small objects is geom_boxplot:
```{r, fig.width=5, fig.height=4}
library(ggplot2)
library(ggrastr)

points_num <- 500
df <- data.frame(x=as.factor(1:points_num %% 2), y=log(abs(rcauchy(points_num))))
gg <- ggplot(df, aes(x=x, y=y)) + scale_color_discrete(guide=F)

boxplot <- gg + geom_boxplot()
print(boxplot)
```

With large number of objects, outlier points become noninformative. For example, here is the rendered plot with `points_num <- 1000000`:

![boxplot_1000000](boxplot_1000000.png)


For such a large number of points, it would be better to jitter them using `geom_boxplot_jitter()`:
```{r, fig.width=4, fig.height=3}
points_num <- 500
df <- data.frame(x=as.factor(1:points_num %% 2), y=log(abs(rcauchy(points_num))))
gg <- ggplot(df, aes(x=x, y=y)) + scale_color_discrete(guide=F)

gg_boxplot_jitter_vec <- gg + geom_boxplot_jitter(outlier.size=0.1, outlier.jitter.width = 0.3, outlier.alpha=0.5)
print(gg_boxplot_jitter_vec)
```

And this geom can be rasterized as well:
```{r, fig.width=4, fig.height=3}
gg_boxplot_jitter_rast <- gg + geom_boxplot_jitter(outlier.size=0.1, outlier.jitter.width = 0.3, outlier.alpha=0.5, raster=TRUE, raster.dpi = 200)
print(gg_boxplot_jitter_rast)
```


```{r}
PrintFileSize(gg_boxplot_jitter_rast, 'Raster')
PrintFileSize(gg_boxplot_jitter_vec, 'Vector')
```

The effect with many points and uninformative outliers is far easier to see using a larger number of points in the boxplots; we encourage users to try values such as `points_num <- 1000000` (or larger integers) themselves.






## Troubleshooting
In the current version, legends can disturb raster plots:
```{r, fig.width=2, fig.height=4}
points_num <- 10
df <- data.frame(x=rnorm(points_num), y=rnorm(points_num), c=as.factor(1:points_num %% 2))
ggplot(df, aes(x=x, y=y, color=c)) + geom_point_rast(size=0.5)
```

To restore the side ratio, the parameters width and height can be used:
```{r, fig.width=2, fig.height=4}
points_num <- 10
df <- data.frame(x=rnorm(points_num), y=rnorm(points_num), c=as.factor(1:points_num %% 2))
ggplot(df, aes(x=x, y=y, color=c)) + geom_point_rast(size=0.5, raster.width = 1)
```